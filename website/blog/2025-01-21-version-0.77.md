---
ia-translated: true
title: 'React Native 0.77 - Novos Recursos de Estilo, Suporte a Páginas de 16KB do Android, Template Swift'
authors: [vonovak, mazen, blakef, robhogan]
tags: [engineering]
date: 2025-01-21
---

Hoje estamos empolgados em lançar o React Native 0.77!

Esta versão traz vários recursos: novas capacidades de estilização, como suporte para `display: contents`, `boxSizing`, `mixBlendMode` e propriedades relacionadas a `outline` para fornecer opções de layout mais poderosas; suporte a páginas de 16KB do Android para ser compatível com os dispositivos Android mais recentes. Também estamos modernizando o template da comunidade migrando-o para Swift, enquanto continuamos a suportar e manter compatibilidade com Objective-C para desenvolvedores que o preferem.

<!--truncate-->

### Destaques

- [Novos Recursos CSS para melhores layouts, dimensionamento e mesclagem](#new-css-features-for-better-layouts-sizing-and-blending)
- [Suporte à versão 15 do Android e suporte a páginas de 16KB](#android-version-15-support--16kb-page-support)
- [Atualizações do CLI e Template da Comunidade](#community-cli-and-template-updates)

### Mudanças Incompatíveis

- [Remoção do streaming de `console.log()` no Metro](#removal-of-consolelog-streaming-in-metro)

## Destaques

### Novos Recursos CSS para melhores layouts, dimensionamento e mesclagem

O React Native 0.77 avança nosso objetivo de alinhar o React Native com a web. Adicionamos suporte para novas propriedades CSS para dar a você mais controle sobre o layout, dimensionamento e mesclagem do seu aplicativo. Essas mudanças podem ajudar a simplificar layouts complexos, adicionar textura e tornar seu aplicativo mais acessível.

:::info
Todos esses novos recursos estão disponíveis apenas para a [New Architecture](/blog/2024/10/23/the-new-architecture-is-here#how-to-upgrade).
:::

#### Layouts mais simples com `display: contents`

A propriedade [`display: contents`](https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents) permite que um elemento desapareça da estrutura de layout enquanto seus filhos ainda são renderizados como se fossem filhos diretos do elemento pai. Pode ser útil para fins de estilização onde você deseja aplicar estilos a elementos filhos sem afetar o layout, ao construir componentes wrapper que devem lidar com eventos, ou se você precisar interagir com a ShadowTree.

Tecnicamente falando, `display: contents` renderiza um elemento sem gerar uma caixa de layout, mas preserva as caixas de layout dos filhos do elemento. O elemento com `display: contents` é efetivamente achatado para fora da hierarquia de visualização.

Vamos dar uma olhada neste exemplo onde queremos exibir um alerta quando um widget é pressionado. Temos um `Widget` vermelho dentro de uma view container:

```jsx title="Container.jsx"
function Container() {
  return (
    <View style={styles.container}>
      <Widget />
    </View>
  );
}
```

![display contents - setup](../static/blog/assets/0.77-display-contents-1.png)

Agora, vamos construir um novo componente wrapper `Alerting`, com o objetivo de alertar o usuário quando um componente abaixo dele é pressionado, usando [experimental pointer events](/blog/2022/12/13/pointer-events-in-react-native). Para clareza, o plano de fundo deste componente é feito azul. Isso pode se parecer com o componente abaixo:

```jsx title="Container.jsx"
function Alerting({children}) {
  return (
    <View
      style={{backgroundColor: 'blue'}}
      onPointerDown={() => alert('Hello World!')}>
      {children}
    </View>
}

function Container() {
  return (
    <View style={styles.container}>
      // highlight-next-line
      <Alerting>
        <Widget />
      </Alerting>
    </View>
  );
}
```

Isso não faz exatamente o que queremos. `Alerting` adiciona uma nova caixa de layout, com seus próprios limites, separados do `Widget` filho. Dependendo do estilo do elemento que está envolvendo, isso pode resultar em mudanças visuais e funcionais significativas. Neste exemplo, o plano de fundo azul responde a toques com um alerta quando queremos que apenas a caixa vermelha "Hello World" alerte quando tocada.

![before display contents](../static/blog/assets/0.77-display-contents-2.gif)

Se tentarmos isso novamente, definindo `display: contents` no wrapper `View` de `Alerting`, vemos alertas apenas quando o usuário pressiona dentro dos limites originais do `Widget`. Isso ocorre porque `Alerting` não adiciona mais sua própria caixa, mas ainda pode observar os eventos de ponteiro propagados do `Widget`.

```jsx title="Container.jsx"
function Alerting({children}) {
  return (
    <View
      // highlight-next-line
      style={{display: 'contents'}}
      onPointerDown={() => alert('Hello World!')}>
      {children}
    </View>
  );
}

// ... function Container ...
```

![after display contents](../static/blog/assets/0.77-display-contents-3.gif)

#### Dimensionamento de caixa

A propriedade `boxSizing` define como as várias propriedades de dimensionamento do elemento (`width`, `height`, `minWidth`, `minHeight`, etc.) são computadas. Se `boxSizing` é `border-box`, esses tamanhos se aplicam à caixa de borda do elemento. Se é `content-box`, eles se aplicam à caixa de conteúdo do elemento. O valor padrão é `border-box`, isso é diferente do valor padrão na web. A [documentação da web](https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing) é uma boa fonte de informação se você deseja aprender mais sobre como essa propriedade funciona.

:::warning
`border-box` tem sido o padrão para sempre neste ponto, e tem sido o único valor de `boxSizing` até que adicionamos `content-box`. Mudar o padrão teria sido uma mudança incompatível que de repente quebraria vários layouts. Decidimos manter `border-box` como valor padrão para garantir compatibilidade retroativa.
:::

Para entender a diferença entre `border-box` e `content-box`, dê uma olhada nestes exemplos, onde ambas as `View`s têm `padding: 20` e `borderWidth: 10`. Ao usar `border-box`, consideramos borda e padding para o dimensionamento; ao usar `content-box`, consideramos apenas o conteúdo para o dimensionamento.

![after display contents](../static/blog/assets/0.77-border-box.png)

#### CSS mixBlendMode

A propriedade `mixBlendMode` permite que você controle como um elemento mescla suas cores com os outros elementos em seu **contexto de empilhamento**. Confira a [documentação MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode) para uma visão geral completa de cada função de mesclagem.

Para ajudar a ter mais controle granular sobre o que está sendo mesclado, também adicionamos a propriedade `isolation`. Definir `isolation: isolate` em uma `View` forçará a formar um **contexto de empilhamento**. Então, você pode definir isso em alguma `View` ancestral para garantir que alguma `View` descendente com `mixBlendMode` não mescle além da `View` **isolada**.

##### Valores de mixBlendMode

- `normal`: O elemento é desenhado em cima de seu plano de fundo sem mesclagem.
- `multiply`: A cor de origem é multiplicada pela cor de destino e substitui o destino.
- `screen`: Multiplica os complementos dos valores de cor do plano de fundo e da origem, depois complementa o resultado.
- `overlay`: Multiplica ou filtra as cores, dependendo do valor da cor do plano de fundo.
- `darken`: Seleciona a mais escura das cores do plano de fundo e da origem.
- `lighten`: Seleciona a mais clara das cores do plano de fundo e da origem.
- `color-dodge`: Clareia a cor do plano de fundo para refletir a cor de origem. Pintar com preto não produz mudanças.
- `color-burn`: Escurece a cor do plano de fundo para refletir a cor de origem. Pintar com branco não produz mudanças.
- `hard-light`: Multiplica ou filtra as cores, dependendo do valor da cor de origem. O efeito é similar a brilhar um holofote intenso no plano de fundo.
- `soft-light`: Escurece ou clareia as cores, dependendo do valor da cor de origem. O efeito é similar a brilhar um holofote difuso no plano de fundo.
- `difference`: Subtrai a mais escura das duas cores constituintes da cor mais clara.
- `exclusion`: Produz um efeito similar ao do modo Difference, mas com menor contraste.
- `hue`: Cria uma cor com o matiz da cor de origem e a saturação e luminosidade da cor do plano de fundo.
- `saturation`: Cria uma cor com a saturação da cor de origem e o matiz e luminosidade da cor do plano de fundo.
- `color`: Cria uma cor com o matiz e saturação da cor de origem e a luminosidade da cor do plano de fundo. Isso preserva os níveis de cinza do plano de fundo e é útil para colorir imagens monocromáticas ou tingir imagens coloridas.
- `luminosity`: Cria uma cor com a luminosidade da cor de origem e o matiz e saturação da cor do plano de fundo. Isso produz um efeito inverso ao do modo Color.

![blend mode](../static/blog/assets/0.77-blend-mode.png)

#### Propriedades outline

Também introduzimos `outlineWidth`, `outlineStyle`, `outlineSpread` e `outlineColor`. Essas propriedades outline funcionam de forma muito similar às respectivas propriedades `border`, mas são renderizadas ao redor da **caixa de borda** em oposição a ao redor da **caixa de padding**. Essas propriedades permitem destacar elementos desenhando seu contorno sem afetar seu layout.

Confira a [documentação MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/outline) para mais detalhes.

![outline props](../static/blog/assets/0.77-outline-props.png)

### Suporte à versão 15 do Android e suporte a páginas de 16KB

#### Edge-to-edge forçado no Android 15

Já fizemos algum trabalho para suportar o Android 15 no lançamento anterior. Uma das mudanças perceptíveis no Android 15 é a exibição edge-to-edge forçada quando você compila aplicativos com `targetSdk` 35.

Se você ainda não analisou isso, consulte nossa [recomendação](https://github.com/react-native-community/discussions-and-proposals/discussions/827) anterior sobre como isso deve ser tratado, pois ignorar isso pode potencialmente quebrar sua UI no aplicativo.

:::note
Se você estiver usando o [`react-native-safe-area-context`](https://www.npmjs.com/package/react-native-safe-area-context) em seu aplicativo, a biblioteca já está lidando com o edge-to-edge forçado para você.
:::

#### Suporte a tamanho de página de 16 KB para Android

O Android 15 introduz suporte para tamanho de página de memória de 16KB, permitindo [melhorias de desempenho](https://developer.android.com/guide/practices/page-sizes#benefits) para aplicativos e mais, mas tornando aplicativos anteriores baseados em 4KB potencialmente incompatíveis em dispositivos futuros; atualmente é um recurso opcional para desenvolvedores testarem em dispositivos selecionados para se prepararem para o tamanho de página de 16 KB ser o padrão do sistema operacional.

Com o lançamento do 0.77, o React Native está pronto para suportar totalmente o tamanho de página de 16 KB e os desenvolvedores poderão testar e lançar aplicativos para dispositivos de 16 KB usando-o.

Consulte [o site oficial do Android Developers](https://developer.android.com/guide/practices/page-sizes) para mais informações sobre o suporte de 16 KB.

### Atualizações do CLI e Template da Comunidade

#### CLI da Comunidade: descontinuação do react-native init

Esta versão completa totalmente a descontinuação do comando `react-native init` que foi [introduzido no React Native 0.75](/blog/2024/08/12/release-0.75#sunsetting-react-native-init).

Como lembrete, você não poderá mais usar o comando `react-native init`, mas terá que:

- [Usar um framework](/blog/2024/06/25/use-a-framework-to-build-react-native-apps) como Expo, com seu próprio comando dedicado para criar um novo projeto: `npx create-expo-app`
- Invocar o CLI da Comunidade diretamente com `npx @react-native-community/cli init`

#### CLI da Comunidade: Remoção dos manipuladores de teclas "run on iOS/Android" do Metro

Nesta versão, removemos os atalhos de teclado 'a' e 'i' do Metro. Esses atalhos eram usados para invocar os comandos `run-android` & `run-ios` do CLI da comunidade.
Esses atalhos de teclado forneciam pior experiência do desenvolvedor e eram raramente usados. Além disso, acreditamos que frameworks são mais adequados para orquestrar as saídas do terminal.

Você pode ler mais sobre essa mudança [neste post dedicado](https://github.com/react-native-community/discussions-and-proposals/discussions/821).

#### Template da Comunidade: Swift como linguagem de programação para aplicativos iOS

:::info
Projetos usando Expo não devem ser afetados por essa mudança.
:::

Essa mudança nos permitiu reduzir o template da comunidade substituindo três arquivos (`main.m`, `AppDelegate.h` e `AppDelegate.mm`) por um único e novo [`AppDelegate.swift`](https://github.com/react-native-community/template/blob/main/template/ios/HelloWorld/AppDelegate.swift).

Isso é tecnicamente uma mudança incompatível: você verá a mudança de Objective-C para Swift no upgrade helper assim:

![Swift Upgrade Helper](../static/blog/assets/0.77-swift-upgrade-helper.png)

Você não precisa migrar para Swift: a variante Objective-C++ do template iOS da comunidade ainda é suportada (observe que você ainda precisa integrar o [`RCTAppDependencyProvider`](#rctappdependencyprovider)). Novos projetos serão gerados usando Swift como linguagem do aplicativo iOS, embora você sempre possa migrar de volta para Objective-C se precisar.

##### Limitações

Se seu aplicativo tiver alguns módulos locais que são escritos em C++, você não poderá registrá-los em Swift conforme mostrado [neste guia](/docs/next/the-new-architecture/pure-cxx-modules#3-registering-the-cxx-turbo-native-module-in-your-app).

Se seu aplicativo se enquadra nesta categoria, pule a migração do AppDelegate para Swift e continue usando Objective-C++ para seu aplicativo.

O núcleo do React Native é principalmente desenvolvido usando C++ para incentivar o compartilhamento de código entre iOS e Android e outras plataformas. A interoperabilidade entre Swift e C++ não é madura nem estável ainda. Estamos procurando maneiras de preencher essa lacuna e permitir que você também migre para Swift.

##### RCTAppDependencyProvider

O React Native 0.77 muda ligeiramente como o aplicativo carrega dependências de terceiros. Esta é uma nova linha no template da comunidade que, se perdida, pode causar alguns problemas em tempo de execução. Certifique-se de adicioná-la ao seu aplicativo.

As linhas equivalentes em Objective-C são as seguintes:

```objc title="AppDelegate.mm"
#import "AppDelegate.h"

#import <React/RCTBundleURLProvider.h>
// highlight-next-line
#import <ReactAppDependencyProvider/RCTAppDependencyProvider.h>


@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.moduleName = @"<Your app Name>";
  // highlight-next-line
  self.dependencyProvider = [RCTAppDependencyProvider new];
  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

// remaining of the AppDelegate

```

## Mudanças Incompatíveis

### Remoção do streaming de `console.log()` no Metro

Queremos que todos os aspectos da depuração do React Native se comportem de forma confiável e correspondam à funcionalidade das ferramentas de navegador modernas. Para atender a essa barra de qualidade, o encaminhamento de log via Metro, originalmente descontinuado em 0.76, é removido em 0.77.

Essa integração dependia de uma abordagem personalizada para se comunicar com o alvo de depuração no dispositivo. Com essa mudança, estamos nos movendo exclusivamente para o Chrome DevTools Protocol (CDP).

- Para visualizar logs JS, use o [React Native DevTools](/docs/react-native-devtools) e seu painel Console totalmente equipado — suportando filtragem de log, inspeção de objetos rica, Live Expressions e mais.
- Você também pode conectar o VS Code como um debugger CDP, via extensões de terceiros como [Expo Tools](https://github.com/expo/vscode-expo) e [Radon IDE](https://ide.swmansion.com/).
  - Observe que essas integrações não são diretamente suportadas pela equipe React. No entanto, estamos trabalhando no suporte de primeira parte do VS Code em 2025.
- O Expo continua a oferecer streaming de log no Expo CLI.

Para mais informações, veja [_Por que os logs JavaScript estão deixando o Metro?_](https://github.com/react-native-community/discussions-and-proposals/discussions/819#:~:text=Why%20are%20JavaScript%20logs%20leaving%20Metro%3F)

### Outras Mudanças Incompatíveis

#### Geral

- Animação
  - Animações de loop nativas não enviam uma atualização de estado do React toda vez que o loop termina.
- Layout
  - `position` de cabeçalhos sticky em `ScrollView` agora será levado em conta.
  - Posicionamento absoluto agora está se comportando de uma maneira mais compatível
- Módulos JS:
  - Remove módulo `ReactFabricInternals`
    - Isso não será mais acessível
- Módulos Nativos
  - Objeto `NativeModules` agora pode ser usado para carregar turbomodules em JS.
    - Isso melhora a compatibilidade entre Native Modules e Turbo Native Modules
- Pacotes
  - dev-middleware: Frameworks devem especificar `serverBaseUrl` relativo ao host do middleware
- Mudanças de API:
  - Removido tipo para `useConcurrentRoot` de `AppRegistry`, pois já era ignorado
  - Removida propriedade `refs` da definição TypeScript de `NativeMethods`.
- Mudanças de UX:
  - Remove "run on iOS" e "run on Android" dos comandos de tecla do servidor de desenvolvimento

#### Android

- Kotlin
  - Esta é a primeira versão do React Native que compila contra Kotlin 2.0.21. Você pode ler mais sobre as mudanças que vêm com Kotlin 2.0 nas [notas de lançamento da linguagem](https://kotlinlang.org/docs/whatsnew2020.html).
- Mudanças de API:
  - Nulabilidade:
    - Getters não primitivos em `ReadableArray` agora são corretamente tipados como opcionais
    - Tornar método `ReactHost.createSurface()` não nulo
  - Renomeado:
    - `DevSupportManagerBase.getCurrentContext()` para `DevSupportManagerBase.getCurrentReactContext()`

Além disso, várias APIs foram removidas ou restritas em visibilidade, então não podem mais ser acessadas. Essas APIs eram internas e não necessárias aos desenvolvedores React Native diretamente. Você pode encontrar a lista completa abaixo:

<details>
<summary>Lista de APIs Android Removidas:</summary>

Os seguintes pacotes agora são internos e não podem mais ser acessados:

- `com.facebook.react.views.progressbar`
- `com.facebook.react.views.safeareaview`
- `com.facebook.react.modules.accessibilityinfo`
- `com.facebook.react.modules.appstate`
- `com.facebook.react.modules.clipboard`
- `com.facebook.react.modules.devmodule`
- `com.facebook.react.modules.reactdevtoolssettings`
- `com.facebook.react.views.unimplementedview`

As seguintes classes agora são internas ou foram removidas, então não podem mais ser acessadas:

- `BackHandler.removeEventListener`
- `BaseViewManagerInterface`
- `BindingImpl`
- `CompositeReactPackage`
- `DebugOverlayTags`
- Método `create()` de `DefaultDevSupportManagerFactory`
- `DevToolsReactPerfLogger`
- `FabricComponents`
- `ImageStoreManager`
- `InteropModuleRegistry`
- `NativeModulePerfLogger`
- `NoopPrinter`
- `NotThreadSafeViewHierarchyUpdateDebugListener`
- `OkHttpCallUtil`
- `PrinterHolder`
- `Printer`
- `ReactDebugOverlayTags`
- `ReactNativeFlipper`
- `ReactViewBackgroundManager`
- `ReactViewGroup.getBackgroundColor()`
- `ReactVirtualTextShadowNode`
- `ReactVirtualTextViewManager`
- `SimpleSettableFuture`
- `SwipeRefreshLayoutManager`
- `TaskCompletionSource`
- Parâmetro `jsBundleLoader` de DefaultReactHost.getDefaultReactHost()
</details>

#### iOS

- Mudanças de API
  - Removido
    - `RCTConstants.RCTGetMemoryPressureUnloadLevel`
    - `partialBatchDidFlush`
    - `RCTRuntimeExecutor`
    - `UseNativeViewConfigsInBridgelessMode`
      - Substituído por uma feature flag apropriada
    - `UseTurboModuleInteropForAllTurboModules`
      - Camada de interoperabilidade está sempre ativada para TMs
  - Alterado
    - Substitui usos de `CGColorRef` por `UIColor`
- `RCTAppDelegate` agora requer usar o `RCTDependencyProvider` para carregar dependências de terceiros
- CocoaPods define versão C++ para todas as dependências de terceiros para evitar problemas de compilação.

<details>
<summary>**React 19?**</summary>

O React 19 foi lançado em 6 de dezembro de 2024.
Naquele momento, já havíamos cortado o branch para o React Native 0.77 e já havíamos lançado três RCs para o React Native 0.77.
Era tarde demais no lançamento do React Native 0.77 para introduzir o React 19 nesta versão.

O React 19 será lançado no React Native 0.78, e já cortamos o branch para esta versão. Você pode experimentá-lo criando um novo aplicativo com o comando:

```no-syntax
npx @react-native-community/cli init YourReact19App --version 0.78.0-rc.0
```

</details>

## Agradecimentos

O React Native 0.77 contém mais de **1061** commits de **161** contribuidores. Obrigado por todo o seu trabalho árduo!

Agradecimentos a todos os autores adicionais que trabalharam na documentação de recursos nesta postagem de lançamento:

- [Jakub Piasecki](https://github.com/j-piasecki) por contribuir para o recurso `display: contents`
- [Nick Gerleman](https://github.com/NickGerleman), [Joe Vilches](https://github.com/joevilches) e [Jorge Cabiedes Acosta](https://github.com/jorge-cab) por lançar os novos recursos de estilização
- [Alan Lee](https://github.com/alanleedev) pelo conteúdo de suporte a páginas de 16Kb do Android
- [Riccardo Cipolleschi](https://github.com/cipolleschi) e [Oskar Kwaśniewski](https://github.com/okwasniewski) por apoiar a migração do template para Swift
- [Nicola Corti](https://github.com/cortinico) pelo conteúdo do ciclo de descontinuação do `react-native init`
- [Alex Hunt](https://github.com/huntie) pelo conteúdo sobre a remoção de `console.log` do metro

### Atualizar para 0.77

Por favor, use o [React Native Upgrade Helper](https://react-native-community.github.io/upgrade-helper/) para visualizar mudanças de código entre versões do React Native para projetos existentes, além dos documentos de Atualização.

Para criar um novo projeto:

```sh
npx @react-native-community/cli@latest init MyProject --version latest
```

Se você usa Expo, o React Native 0.77 será suportado no Expo SDK 52 (instruções sobre como atualizar o React Native dentro do seu projeto Expo para 0.77.0 estarão disponíveis em uma postagem de blog separada do Expo em um futuro próximo).

:::info
0.77 é agora a versão estável mais recente do React Native e 0.74.x passa a não suportada. Para mais informações veja [política de suporte do React Native](https://github.com/reactwg/react-native-releases/blob/main/docs/support.md#releases-support-policy). Pretendemos publicar uma atualização final de fim de vida do 0.74 em um futuro próximo.
:::

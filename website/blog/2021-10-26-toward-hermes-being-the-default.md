---
ia-translated: true
title: Rumo ao Hermes Sendo o Padrão
authors: [huxpro]
tags: [announcement]
---

Desde que [anunciamos o Hermes em 2019](https://engineering.fb.com/2019/07/12/android/hermes/), ele tem ganhado cada vez mais adoção na comunidade. A equipe da [Expo](https://expo.dev/), que mantém um meta-framework popular para apps React Native, recentemente [anunciou suporte experimental](https://blog.expo.dev/expo-sdk-42-579aee2348b6) [para Hermes](https://blog.expo.dev/expo-sdk-43-beta-is-now-available-47dc54a8d29f) após ser [um dos recursos mais solicitados do Expo](https://expo.canny.io/feature-requests/p/enabling-hermes). A equipe do [Realm](https://realm.io/), um banco de dados móvel popular, também lançou recentemente seu [suporte alpha](https://github.com/realm/realm-js/issues/3940) para Hermes. Neste post, queremos destacar alguns dos progressos mais emocionantes que fizemos nos últimos dois anos para empurrar o Hermes em direção a ser _o melhor_ motor JavaScript para React Native. Olhando para frente, estamos confiantes de que com essas melhorias e mais por vir, podemos tornar o Hermes o motor JavaScript padrão para React Native em todas as plataformas.

<!--truncate-->

## Otimizando para React Native

O recurso definidor do Hermes é como ele executa o trabalho de compilação ahead-of-time, significando que apps React Native com Hermes habilitado são enviados com bytecode pré-compilado otimizado em vez de código-fonte JavaScript simples. Isso reduz drasticamente a quantidade de trabalho necessário para iniciar seu produto para os usuários. Medições de apps do Facebook e da comunidade sugeriram que habilitar o Hermes frequentemente cortou a métrica TTI (ou [Time-To-Interactive](https://web.dev/interactive/)) de um produto quase pela metade.

Dito isso, temos trabalhado em melhorar o Hermes em muitos outros aspectos para torná-lo ainda melhor como um motor JavaScript especializado para React Native.

### Construindo um Novo Coletor de Lixo para Fabric

Com o próximo renderer [Fabric](https://github.com/react-native-community/discussions-and-proposals/issues/4) na nova arquitetura do React Native, será possível chamar JavaScript sincronamente na thread de UI. No entanto, isso significa que se a thread JavaScript demorar muito para executar, pode causar quedas perceptíveis de quadros da UI e bloquear entradas do usuário. A [renderização concorrente](https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html) habilitada pelo React [Fiber](https://reactjs.org/docs/faq-internals.html#what-is-react-fiber) evitará agendar tarefas JavaScript longas dividindo o trabalho de renderização em pedaços. No entanto, há outra fonte comum de latência da thread JavaScript — quando o motor JavaScript precisa "parar o mundo" para executar uma coleta de lixo (GC).

O coletor de lixo padrão anterior no Hermes, [GenGC](https://hermesengine.dev/docs/gengc/), era um coletor de lixo geracional single-threaded. As novas gerações usam uma estratégia típica de cópia semi-espaço, e as gerações antigas usam uma estratégia mark-compact para torná-lo realmente bom em devolver memória agressivamente ao sistema operacional. Devido ao seu single-thread, o GenGC tem a desvantagem de causar longas pausas de GC. Em apps tão complicados quanto o Facebook para Android, observamos uma pausa média de 200ms, ou 1,4s no p99. Já vimos ser tão longo quanto 7 segundos, considerando a grande e diversa base de usuários do Facebook para Android.

Para mitigar isso, implementamos um GC totalmente novo _majoritariamente concorrente_ chamado [Hades](https://hermesengine.dev/docs/hades). O Hades coleta sua geração jovem exatamente da mesma forma que o GenGC, mas gerencia sua geração antiga com um coletor mark-sweep estilo snapshot-at-the-beginning, que pode reduzir significativamente o tempo de pausa do GC executando a maior parte de seu trabalho em uma thread em segundo plano sem bloquear a thread principal do motor de executar código JavaScript. **Nossas estatísticas mostram que o Hades pausa apenas 48ms no p99.9 em dispositivos de 64 bits (34x mais rápido que o GenGC!)** e cerca de 88ms no p99.9 em dispositivos de 32 bits (onde opera como um GC _incremental_ single-threaded). Essas melhorias de tempo de pausa podem vir ao custo de throughput geral, devido à necessidade de write barriers mais caras, alocação baseada em freelist mais lenta (em oposição a um bump pointer allocator) e maior fragmentação de heap. Achamos que são as trade-offs certas, e conseguimos alcançar menor consumo de memória geral via coalescing e otimizações de memória adicionais sobre as quais falaremos.

### Atacando Pontos de Dor de Desempenho

O tempo de inicialização de aplicações é crítico para o sucesso de muitos apps, e estamos continuamente empurrando o limite para React Native. Para qualquer novo recurso JavaScript que implementamos no Hermes, monitoramos cuidadosamente seu impacto no desempenho de produção e garantimos que não regridam métricas. No Facebook, estamos atualmente experimentando com um [perfil de transformação Babel dedicado para Hermes no Metro](https://github.com/facebook/react-native/blob/main/packages/react-native-babel-preset/src/configs/main.js#L41) para substituir uma dúzia de transformações Babel pelas implementações ESNext nativas do Hermes. Conseguimos observar **18-25% de melhorias de TTI** em muitas superfícies e **diminuições gerais de tamanho de bytecode** e esperamos ver resultados similares para OSS.

Além do desempenho de inicialização, identificamos a pegada de memória como uma oportunidade de melhoria em apps React Native especialmente para [realidade virtual.](https://reactnative.dev/blog/2021/08/26/many-platform-vision#expanding-to-new-platforms) Graças ao controle de baixo nível que temos como um motor JavaScript, conseguimos entregar rodadas de otimizações de memória espremendo bits e bytes:

1. Anteriormente, todos os valores JavaScript eram representados como valores tagged com codificação NaN-boxing de 64 bits para representar doubles de ponto flutuante e ponteiros em arquitetura de 64 bits. No entanto, isso é desperdiçador na prática porque a maioria dos números são inteiros pequenos (SMI) e o heap JavaScript de aplicações client-side geralmente não deve ser maior que 4GiB. Para resolver isso, introduzimos uma nova codificação de 32 bits na qual SMI e ponteiros são codificados em 29 bits (porque ponteiros são alinhados a 8 bytes, podemos assumir que os 3 bits inferiores são sempre zero), e o resto dos números JS são colocados em box no heap. **Isso reduziu o tamanho do heap JavaScript em ~30%.**
2. Diferentes tipos de objetos JavaScript são representados como diferentes tipos de células gerenciadas por GC no heap JavaScript. Ao otimizar agressivamente o layout de memória dos cabeçalhos para essas células, **conseguimos reduzir o uso de memória em mais ~15%**.

Uma de nossas decisões chave com o Hermes foi não implementar um [compilador just-in-time (JIT)](https://en.wikipedia.org/wiki/Just-in-time_compilation) porque acreditamos que para a maioria dos apps React Native, os custos adicionais de warm-up e pegadas extras em binário e memória não valeriam realmente a pena. Por anos, investimos muito esforço em otimizar o desempenho do interpretador e otimizações do compilador para tornar o throughput do Hermes competitivo com outros motores para cargas de trabalho React Native. Continuamos focados em melhorar o throughput identificando gargalos de desempenho de todos os lugares (loop de dispatch do interpretador, layout de stack, modelo de objeto, GC, etc.). Espere mais números em próximos lançamentos!

### Pioneirismo em Integrações Verticais

No Facebook, preferimos colocar projetos juntos dentro de um grande [monorepo](https://en.wikipedia.org/wiki/Monorepo). Ao ter o motor (Hermes) e o host (React Native) iterando proximamente juntos, abrimos muito espaço para integrações verticais. Para citar alguns:

- O Hermes suporta [depuração JavaScript em dispositivo com o depurador Chrome](https://reactnative.dev/docs/hermes#debugging-js-on-hermes-using-google-chromes-devtools) falando o [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/). É melhor que o legado "[Remote JS Debugging](https://reactnative.dev/docs/debugging#chrome-developer-tools)" (que usa um proxy no app para executar JS no Chrome desktop) porque suporta depuração de chamadas nativas síncronas e garantiu um ambiente de runtime consistente. Junto com React DevTools, Metro, Inspector e assim por diante, o depurador Hermes agora faz parte do [Flipper](https://reactnative.dev/blog/2020/03/26/version-0.62) para fornecer uma experiência de desenvolvedor integrada.
- Objetos alocados durante o caminho de inicialização de apps React Native frequentemente têm vida longa e não seguem a _hipótese geracional_ aproveitada por GCs geracionais. Portanto, [configuramos o Hermes no React Native](https://github.com/facebook/react-native/blob/main/ReactAndroid/src/main/java/com/facebook/hermes/reactexecutor/OnLoad.cpp#L37-L42) para alocar os primeiros 32MiB diretamente nas gerações antigas (conhecido como _pre-tenuring_) para evitar acionar pausas de GC e atrasar TTI.
- A nova arquitetura do React Native é fortemente baseada em [JSI (ou JavaScript Interface)](https://github.com/react-native-community/discussions-and-proposals/issues/91), uma API leve e de propósito geral para embutir um motor JavaScript em um programa C++. Ao ter a equipe mantendo o motor JS também mantendo a implementação da API JSI, estamos confiantes em fornecer a melhor integração possível que é confiável, performática e testada em batalha na escala do Facebook.
- Conseguir primitivas de concorrência JavaScript (ex. [promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)) e primitivas de concorrência da plataforma (ex. [microtasks](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide)) tanto semanticamente corretas quanto performáticas são críticas para renderização concorrente do React e o futuro de apps React Native. Historicamente, promises no React Native eram [polyfilled](https://github.com/facebook/react-native/blob/main/Libraries/Core/polyfillPromise.js#L37) usando APIs [`setImmediate`](https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate) não padronizadas. Estamos trabalhando para tornar promises nativas e microtasks de motores JS disponíveis via JSI, e introduzindo [`queueMicrotask`](https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask), uma adição recente ao padrão web, à plataforma, para melhor suportar código JavaScript assíncrono moderno.

## Trazendo Toda a Comunidade Junto

O Hermes tem sido realmente ótimo para nós no Facebook. Mas nosso trabalho não está feito até que nossa comunidade possa usar o Hermes para alimentar experiências em todo o ecossistema, para que todos aproveitem todos os seus recursos e abracem seu potencial completo.

### Expandindo para Novas Plataformas

O Hermes foi inicialmente open source apenas para React Native no Android. Desde então, ficamos emocionados em ver membros de nossa comunidade expandindo o suporte do Hermes para [muitas outras plataformas que o ecossistema do React Native expandiu](https://reactnative.dev/blog/2021/08/26/many-platform-vision).

[Callstack](https://callstack.com/) liderou o esforço de trazer [Hermes para iOS no React Native 0.64](https://reactnative.dev/blog/2021/03/12/version-0.64). Eles escreveram uma [série de artigos](https://callstack.com/blog/bringing-hermes-to-ios-in-react-native/) e hospedaram um [podcast](https://callstack.com/podcasts/react-native-0-64-with-hermes-for-ios-ep-5) sobre como conseguiram isso. De acordo com seus benchmarks, o Hermes foi capaz de **entregar consistentemente ~40% de melhoria na inicialização e ~18% de redução de memória no iOS** comparado ao JSC para o app Mattermost, com apenas 2,4 MiB de sobrecarga de tamanho do app. Eu encorajo você a [ver ao vivo com seus próprios olhos](https://callstack.com/blog/hermes-performance-on-ios/).

A Microsoft tem trazido [Hermes para React Native para Windows e macOS](https://microsoft.github.io/react-native-windows/docs/hermes). [No Microsoft Build 2020](https://youtu.be/QMFbrHZnvvw?t=389), a Microsoft compartilhou que o impacto de memória do Hermes ([working set](https://en.wikipedia.org/wiki/Working_set)) é 13% menor que o motor Chakra no React Native para Windows. Recentemente, em alguns benchmarks sintéticos, eles descobriram que o Hermes 0.8 (enviado com Hades e otimização de compressão de ponteiro e SMI mencionada anteriormente) **usa 30%-40% menos memória que outros motores**. Não surpreendentemente, a experiência de chamada de vídeo do [Messenger desktop](https://www.messenger.com/desktop) construída em React Native, também é alimentada pelo Hermes.

Por último, mas não menos importante, o Hermes também tem alimentado todas as experiências de realidade virtual construídas com a família de tecnologias React no Oculus, incluindo Oculus Home.

### Apoiando Nossa Comunidade

Reconhecemos que ainda existem bloqueadores que impedem partes da comunidade de adotar o Hermes e estamos comprometidos em construir suporte para esses recursos ausentes. Nosso objetivo é ser completo em recursos para que o Hermes seja a escolha certa para a maioria dos apps React Native. Aqui está como a comunidade já moldou o roadmap do Hermes:

<!-- alex ignore just fellowship -->

- [`Proxy` e `Reflect`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Meta_programming) foram originalmente excluídos do Hermes porque o Facebook não os usa. Também estávamos preocupados que adicionar Proxy prejudicasse o desempenho de busca de propriedade mesmo quando Proxy não fosse usado. Mas Proxy rapidamente se tornou [o recurso mais solicitado](https://github.com/facebook/hermes/issues/33) do Hermes devido a bibliotecas populares como [MobX](https://mobx.js.org/README.html) e [Immer](https://immerjs.github.io/immer/). Avaliamos cuidadosamente e decidimos construí-lo apenas para a comunidade, e conseguimos implementá-lo com custo muito baixo. Como este é um recurso que não usamos, confiamos em nossa comunidade para provar sua estabilidade. Começamos testando Proxy atrás de uma flag e criamos pacotes npm opt-in para [release v0.4](https://github.com/facebook/hermes/issues/33#issuecomment-668374607) e [v0.5](https://github.com/facebook/hermes/issues/33#issuecomment-668374607), e está [habilitado por padrão a partir da v0.7](https://github.com/facebook/hermes/releases/tag/v0.7.0).
- [Especificação da API de Internacionalização ECMAScript (ECMA-402, ou `Intl`)](https://hermesengine.dev/docs/intl) foi [o segundo recurso mais solicitado](https://github.com/facebook/hermes/issues/23). `Intl` é um enorme conjunto de APIs e frequentemente requer que a implementação inclua **6MB de valor** de dados [Unicode CLDR](https://cldr.unicode.org/index). É por isso que polyfills como [FormatJS (a.k.a. `react-intl`)](https://github.com/formatjs/formatjs) e motores JS como a [variante internacional do JSC da comunidade](https://github.com/react-native-community/jsc-android-buildscripts#international-variant) são tão grandes. Para evitar aumentar substancialmente o tamanho binário do Hermes, decidimos implementá-lo com outra estratégia consumindo e mapeando as facilidades ICU fornecidas pelas bibliotecas incluídas nos sistemas operacionais, ao custo de alguma (frequentemente menor) variação nos comportamentos entre plataformas.
  - A Microsoft colaborou para construir suporte no Android. Ele cobre quase tudo do ECMA-402 até ES2020, **com apenas um impacto de tamanho tão pequeno quanto 3% (57-62K por ABI)**. Fizemos [uma enquete no Twitter](https://twitter.com/tmikov/status/1336442786694893568) e os resultados foram fortemente a favor de incluir `Intl` por padrão, então foi isso que fizemos e está disponível a partir do [release v0.8](https://github.com/facebook/hermes/releases/tag/v0.8.0).
  - O Facebook patrocinou [Major League Hacking](https://mlh.io/) para lançar um [programa de fellowship open source remoto](https://news.mlh.io/welcoming-facebook-back-as-a-sponsor-of-the-2020-2021-mlh-fellowship-08-12-2020). No ano passado, lançamos o [profiler de amostragem do Hermes](https://reactnative.dev/docs/profile-hermes). Este ano, nossos fellows estarão trabalhando com membros do Hermes, React Native e Callstack, para adicionar suporte para Hermes `Intl` no iOS. Fique ligado!
- Apreciamos que as pessoas têm trabalhado conosco para descobrir issues afetando a comunidade.
  - As pessoas nos ajudaram a identificar divergências críticas de especificação como [estabilidade do `Array.prototype.sort`](https://github.com/facebook/hermes/issues/212) corrigida no [ES2019](https://github.com/tc39/ecma262/pull/1340). Isso foi corrigido e estará disponível no próximo lançamento.
  - As pessoas descobriram que nosso limite padrão de tamanho de heap era muito pequeno e causou [pressão de GC desnecessária](https://github.com/facebook/hermes/issues/295) e [crashes OOM](https://github.com/facebook/hermes/issues/511) para muitos usuários que não estão familiarizados com personalização das configs de GC do Hermes. Então aumentamos de 512MiB para 3GiB para ser mais do que suficiente para a maioria dos usuários por padrão.
  - As pessoas também relataram que nossa implementação especializada de `Function.prototype.toString` [causou queda de desempenho em bibliotecas fazendo detecção de recurso inadequada](https://github.com/facebook/hermes/issues/471#issuecomment-820123463) e [bloqueou usuários de fazer injeção de código-fonte](https://github.com/facebook/hermes/issues/114#issuecomment-887106990). Isso nos ajudou a fortalecer nossa posição de que o Hermes, sempre que possível, não deve atrapalhar os desenvolvedores e respeitar práticas de facto.

## Resumo

Em resumo, nossa visão é tornar o Hermes pronto para ser o motor JavaScript padrão em todas as plataformas React Native. Já começamos a trabalhar nisso, e queremos ouvir de todos vocês sobre esta direção.

É extremamente importante para nós preparar o ecossistema para uma adoção suave. Encorajamos você a experimentar o Hermes, e abrir issues em nosso [repositório GitHub](https://github.com/facebook/hermes) para quaisquer feedbacks, perguntas, solicitações de recursos e incompatibilidades.

## Agradecimentos

Gostaríamos de agradecer à equipe do Hermes, à equipe do React Native e aos muitos contribuidores da comunidade React Native por seu trabalho para melhorar o Hermes.

Eu também gostaria de agradecer pessoalmente (em ordem alfabética) Eli White, Luna Wei, Neil Dhar, Tim Yung, Tzvetan Mikov e muitos outros por sua ajuda durante a escrita.
